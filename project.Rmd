#library

```{r}
library(openxlsx)
options(stringsAsFactors = F)
options(java.parameters = '-Xmx8000m')
library(nortest)
library(ggplot2)
library(vegan)
library(readr)
#library(rJava)
library("viper")
library(magrittr)
library(pheatmap)
library(mvtnorm)
library(swamp)#ComBat
#library('gPCA')#gpca
library('bapred')
library(Harman)#harman
library(sva)#SVA
library(grid)
library(gridExtra)
library(ggrepel)
library(ggfortify)
library(magrittr)
library(dplyr)
library(missForest)
library(missMDA)
library(pcaMethods)
library(PEMM)
library(viper)
library(stats)
library(reshape2)
library(bladderbatch)
library('imputeLCMD')
library("hydroGOF")
library("pls")
library(sn)
      
svd = function (x, nu = min(n, p), nv = min(n, p), LINPACK = TRUE) 
{
 # print("LINPACK:"); print(LINPACK) 
  if (!missing(LINPACK)) 
    warning("the LINPACK argument has been defunct since R 3.1.0")
  x <- as.matrix(x)
  if (any(!is.finite(x))) 
    stop("infinite or missing values in 'x'")
  dx <- dim(x)
  n <- dx[1L]
  p <- dx[2L]
  if (!n || !p) 
    stop("a dimension is zero")
  La.res <- La.svd(x, nu, nv)
  res <- list(d = La.res$d)
  if (nu) 
    res$u <- La.res$u
  if (nu) 
    res$u <- La.res$u
  if (nv) {
    if (is.complex(x)) 
      res$v <- Conj(t(La.res$vt))
    else res$v <- t(La.res$vt)
  }
  res
}
assignInNamespace("svd", svd, "base")
```

#ProJect code

```{r}

predi <- function(object, newdata, ncomp = 1:object$ncomp, comps,
                        type = c("response", "scores"),
                        na.action = na.pass, ...)
{
    if (missing(newdata) || is.null(newdata))
        newX <- model.matrix(object)
    else if (is.matrix(newdata)) {
        ## For matrices, simply check dimension:
        if (ncol(newdata) != length(object$Xmeans))
            stop("'newdata' does not have the correct number of columns")
        newX <- newdata
    } else {
        Terms <- delete.response(terms(object))
        m <- model.frame(Terms, newdata, na.action = na.action)
        if (!is.null(cl <- attr(Terms, "dataClasses")))
            .checkMFClasses(cl, m)
   mm <- model.matrix(Terms, m)
   saveattr <- attributes(mm)
   #print(mm)
   intercept <- which(saveattr$assign == 0)
   if (length(intercept))
   {
   mm <- mm[,-intercept, drop=FALSE]
   saveattr$dim <- dim(mm)
   saveattr$dimnames <- dimnames(mm)
   saveattr$assign <- saveattr$assign[-intercept]
   attributes(mm) <- saveattr
   }
   newX <- mm
    }

    nobs <- dim(newX)[1]

    ## Perform any scaling:
    if (!is.null(object$scale)) newX <- newX / rep(object$scale, each = nobs)
    type <- match.arg(type)
    if (type == "response") {
        if (missing(comps) || is.null(comps)) {
            ## Predict with models containing ncomp[1] components,
            ## ncomp[2] components, etc.
            if (missing(newdata)) return(fitted(object)[,,ncomp, drop=FALSE])
            B <- coef(object, ncomp = ncomp, intercept = TRUE)
            dPred <- dim(B)
            dPred[1] <- dim(newX)[1]
            dnPred <- dimnames(B)
            dnPred[1] <-
                if(is.null(dimnames(newX))) list(NULL) else dimnames(newX)[1]
            pred <- array(dim = dPred, dimnames = dnPred)
            for (i in seq(along = ncomp))
                pred[,,i] <- newX %*% B[-1,,i] + rep(B[1,,i], each = nobs)
            return(pred)
        } else {
            ## Predict with a model containing the components `comps'
            B <- rowSums(coef(object, comps = comps), dims = 2)
            B0 <- object$Ymeans - object$Xmeans %*% B
            pred <- newX %*% B + rep(B0, each = nobs)
            if (missing(newdata) && !is.null(object$na.action))
                pred <- napredict(object$na.action, pred)
            return(pred)
        }
    } else {
        if (missing(comps) || is.null(comps)) comps <- ncomp
        if (missing(newdata)) {
            TT <- object$scores[,comps]
            if (!is.null(object$na.action))
                TT <- napredict(object$na.action, TT)
        } else {
            if (is.null(object$projection))
                stop("`object' has no `projection' component.'")
            TT <- (newX - rep(object$Xmeans, each = nobs)) %*%
                object$projection[,comps]
        }
        return(TT)
    }
}
pfit <- function (formula, ncomp, data,  scale = TRUE, center = TRUE,...) 
{
    mf <- model.frame(formula,data)
    mt <- attr(mf, "terms")
    Y <- model.response(mf, "numeric")
    if (is.matrix(Y)) {
        if (is.null(colnames(Y))) 
            colnames(Y) <- paste("Y", 1:dim(Y)[2], sep = "")
    }
    else {
        Y <- as.matrix(Y)
        colnames(Y) <- deparse(formula[[2]])
    }
    mm <- model.matrix(mt, mf)
    saveattr <- attributes(mm)
    #print(mm)
    intercept <- which(saveattr$assign == 0)
    if (length(intercept))
    {
    mm <- mm[,-intercept, drop=FALSE]
    saveattr$dim <- dim(mm)
    saveattr$dimnames <- dimnames(mm)
    saveattr$assign <- saveattr$assign[-intercept]
    attributes(mm) <- saveattr
    }
    X <- mm
    nobj <- dim(X)[1]
    npred <- dim(X)[2]
    if (length(attr(mt, "term.labels")) == 1 && !is.null(colnames(mf[[attr(mt, 
        "term.labels")]]))) 
       { colnames(X) <- sub(attr(mt, "term.labels"), "", colnames(X))
       print("yes")}
    ncomp <- min(nobj - 1, npred)
    sdscale <- isTRUE(scale)
    val <- NULL
    if (sdscale) {
        scale <- sqrt(colSums((X - rep(colMeans(X), each = nobj))^2)/(nobj - 
            1))
        X <- X/rep(scale, each = nobj)
    }

    Y <- as.matrix(Y)
    dnX <- dimnames(X)
    dnY <- dimnames(Y)
    dimnames(X) <- dimnames(Y) <- NULL
    nobj  <- dim(X)[1]
    npred <- dim(X)[2]
    nresp <- dim(Y)[2]
    Xmeans <- colMeans(X)
    X <- X - rep(Xmeans, each = nobj)
    Ymeans <- colMeans(Y)
    Y <- Y - rep(Ymeans, each = nobj)
    R <- P <- matrix(0, ncol = ncomp, nrow = npred)
    tQ <- matrix(0, ncol = nresp, nrow = ncomp)
    B <- array(0, c(npred, nresp, ncomp))
    W <- P                       
    U <- TT <- matrix(0, ncol = ncomp, nrow = nobj)
    tsqs <- rep.int(1, ncomp)       
    fitted <- array(0, c(nobj, nresp, ncomp))
    XtY <- crossprod(X, Y)
    for (a in 1:ncomp) {
        if (nresp == 1) {
            w.a <- XtY / sqrt(c(crossprod(XtY)))
        } else {
            if (nresp < npred) {
                q <- eigen(crossprod(XtY), symmetric = TRUE)$vectors[,1]
                w.a <- XtY %*% q
                w.a <- w.a / sqrt(c(crossprod(w.a)))
            } else {
                w.a <- eigen(XtY %*% t(XtY), symmetric = TRUE)$vectors[,1]
            }
        }
        r.a <- w.a
        if (a > 5) {
            r.a <- r.a - colSums(crossprod(w.a, P[,1:(a-1), drop=FALSE]) %*% t(R[,1:(a-1), drop=FALSE]))
        } else if (a > 1) {
            for (j in 1:(a - 1))
                r.a <- r.a - c(P[,j] %*% w.a) * R[,j]
        }
        t.a <- X %*% r.a
        tsq <- c(crossprod(t.a))
        p.a <- crossprod(X, t.a) / tsq
        q.a <- crossprod(XtY, r.a) / tsq
        XtY <- XtY - (tsq * p.a) %*% t(q.a)
        R[,a]  <- r.a
        P[,a]  <- p.a
        tQ[a,] <- q.a
        B[,,a] <- R[,1:a, drop=FALSE] %*% tQ[1:a,, drop=FALSE]
            tsqs[a] <- tsq
            u.a <- Y %*% q.a / c(crossprod(q.a))
            if (a > 1) u.a <- u.a - TT %*% (crossprod(TT, u.a) / tsqs)
            U[,a]  <- u.a
            TT[,a] <- t.a
            W[,a]  <- w.a
            fitted[,,a] <- TT[,1:a] %*% tQ[1:a,, drop=FALSE]
        }
    residuals <- - fitted + c(Y)
    fitted <- fitted + rep(Ymeans, each = nobj) # Add mean
    objnames <- dnX[[1]]
    if (is.null(objnames)) objnames <- dnY[[1]]
    prednames <- dnX[[2]]
    respnames <- dnY[[2]]
    compnames <- paste("Comp", 1:ncomp)
    nCompnames <- paste(1:ncomp, "comps")
    dimnames(TT) <- dimnames(U) <- list(objnames, compnames)
    dimnames(R) <- dimnames(W) <- dimnames(P) <-
        list(prednames, compnames)
    dimnames(tQ) <- list(compnames, respnames)
    dimnames(B) <- list(prednames, respnames, nCompnames)
    dimnames(fitted) <- dimnames(residuals) <-
        list(objnames, respnames, nCompnames)
    class(TT) <- class(U) <- "scores"
    class(P) <- class(W) <- class(tQ) <- "loadings"
    z <- list(coefficients = B,
         scores = TT, loadings = P,
         loading.weights = W,
         Yscores = U, Yloadings = t(tQ),
         projection = R,
         Xmeans = Xmeans, Ymeans = Ymeans,
         fitted.values = fitted, residuals = residuals,
         Xvar = colSums(P * P) * tsqs,
         Xtotvar = sum(X * X))
    z$ncomp <- ncomp
    z$scale <- scale
    z$center <- TRUE
    z$validation <- val
    z$terms <- mt
    z$model <- mf
    z
}
initial <-function(data2,subdata2,flag=1)# use -1 when MNAR
{
  d=data2[!is.na(data2)]
  cp.est <- sn.mple(y=d,opt.method = "nlminb")$cp
  data=(data2-cp.est[1])/cp.est[2]
  meand=cp.est[1]
  sdd=cp.est[2]
  subdata=c()
  submean=c()
  subsd=c()
  trash=0
  for(i in 1:ncol(subdata2))
  {
    tmpre=subdata2[,i]
    d=tmpre[!is.na(tmpre)]
    cp.est <- sn.mple(y=d,opt.method = "nlminb")$cp
    #print(cp.est)
    submean=rbind(submean, cp.est[1])
    subsd=rbind(subsd,cp.est[2])
    kk=(tmpre-cp.est[1])/cp.est[2]
    subdata=cbind(subdata,kk)
  }
  colnames(subdata)=colnames(subdata2)
  rownames(submean)=colnames(subdata2)
  rownames(subsd)=colnames(subdata2)
  #subdata=scale(subdata2)
  lis=which(data %in% NA)
  impdata=data
 
  t=cbind(data,subdata)
  tuse=c()
  for(i in 1:nrow(t))
  {
    if(!is.na(sum(t[i,]))) tuse=rbind(tuse,t[i,])
  }
 
  if(length(tuse)==0 || nrow(tuse)<=ncol(tuse)*10)
  {
    for(k in 1:nrow(t))
    {
      #print(k)
      tmp=t[k,]
      if(length(which(is.na(tmp)))<length(tmp)*0.2)
      {
        tti=which(is.na(tmp))
        tmpmean=mean(tmp,na.rm=T)
        for(l in tti)
        {tmp[l]=tmpmean+runif(1,-1e-4,1e-4)}
        b=cbind(t(tmp))
        tuse=rbind(tuse,b)
        #}
      }
    }
  }
 
  model1res=c()
  model2res=c()
  idr=c()
  cnt=0
  if(length(tuse)==0 || nrow(tuse)<=10 || nrow(tuse)<ncol(tuse)*5)
  {
    reccor=c()
    for(j in 2:ncol(t))
    {
      tmpcor=c()
      for(i in 1:nrow(t))
      {
      if(!is.na(sum(t[i,c(1,j)]))) tmpcor=rbind(tmpcor,t[i,c(1,j)])
      }
      tmp=cor(tmpcor[,1],tmpcor[,2],method="pearson")
      reccor=rbind(reccor,cbind(j,tmp))
    }
    filid=reccor[order(reccor[,2]),1]
    trash=1
    tmpuse=tuse
    while(length(filid)>4 && trash<=length(filid)/2 && (length(tmpuse)==0 || nrow(tmpuse)<ncol(tmpuse)*5))
    {
      fil=filid[-c(1:trash)]
      fil=sort(fil)
      tt=t[,c(1,fil)]
      tmpuse=c()
      for(k in 1:nrow(tt))
      {
      #print(k)
      tmp=tt[k,]
      if(length(which(is.na(tmp)))<length(tmp)*0.2)
      {
        tti=which(is.na(tmp))
        tmpmean=mean(tmp,na.rm=T)
        for(l in tti)
        {tmp[l]=tmpmean+runif(1,-1e-4,1e-4)}
        b=cbind(t(tmp))
        tmpuse=rbind(tmpuse,b)
        #}
      }
      }
      trash=trash+1
    }
    tuse=tmpuse
  }
  ###
  if(nrow(tuse)>=10 && nrow(tuse)>ncol(tuse)*5)
  {
  for(i in 1:nrow(tuse))# 1:nrow(tuse)
  {
   
    corr=c()
    a=1:nrow(tuse)
    a=a[-i]
    df=tuse[i,2:ncol(tuse)]
    for(j in a)
    {
      corr=rbind(corr,cbind(j,cor(df,tuse[j,2:ncol(tuse)],method="pearson")))
    }
    subl=which(abs(corr[,2])>0.9)
    subl=corr[subl,1]
    if(length(subl)<ncol(tuse)*10 && nrow(tuse)>=ncol(tuse)*10)
    {
      corrtmp=corr[order(abs(corr[,2]),decreasing = T),]
      subl=corrtmp[1:(ncol(tuse)*10),1]
    }
    if(nrow(tuse)<ncol(tuse)*10 && nrow(tuse)>=ncol(tuse)*5)
    {
      subl=c(1:nrow(tuse))
    }
    subl=sort(subl)
    all=tuse[subl,]
    all=data.frame(all) #all的列数必满足要求
    colnames(all)[1]="y2"
    model <- pfit(y2~., data=all)
    class(model)="mvr"
    distance=cor(all,all,method="pearson")
    distance=distance[1,2:ncol(distance)]
   
    tmpall=as.numeric(model$Xvar)/model$Xtotvar
    tmpall2=tmpall
    tmpid=model$ncomp
    if(tmpid>2)
    {
      for(ttt in 2:model$ncomp)
      {
        tmpall2[ttt]=tmpall[ttt]+tmpall2[ttt-1]
        if(is.na(tmpall2[ttt]))
          {break}
        if(tmpall2[ttt]>=0.9) {
          tmpid=ttt
          break}
       
      }
    }
   
    if(tmpid<=2) tmpid=2
   
    #jsid=5
    jsid=tmpid
    #jsid=10
    tmpsort=sort(abs(distance),decreasing=T)[jsid]
    disname=colnames(all)[2:ncol(all)]
    trashdisname=disname[abs(distance)<tmpsort]
    distance[abs(distance)<tmpsort]=0
    distance=abs(distance)/sum(abs(distance))
    #  pcr_pred=(sum(df*distance)+pcr_pred2)/2
    notall=all[,!colnames(all)%in%trashdisname]
    model2=pfit(y2~., data=notall)
    class(model2)="mvr"
    df=t(df)
    notdf=df[,!disname%in%trashdisname]
    notdf=data.frame(notdf)
    notdf=t(notdf)
    pcr_pred1=sum(df*distance)
    tmpall=as.numeric(model2$Xvar)/model2$Xtotvar
    tmpid2=model2$ncomp
    tmpall2=tmpall
    if(tmpid2>2)
    {
    for(ttt in 2:model2$ncomp)
    {
      tmpall2[ttt]=tmpall[ttt]+tmpall2[ttt-1]
       if(is.na(tmpall2[ttt]))
               {
              tmpid2=ttt-1
              break}
      if(tmpall2[ttt]>=1) {
        tmpid2=ttt
        break}
    }
    }
    if(tmpid2<model2$ncomp) cnt=cnt+1
    pcr_pred2=predi(model2, notdf,ncomp=tmpid2)
    if(is.na(pcr_pred2) ||abs(pcr_pred2)>abs(pcr_pred1*3) || abs(pcr_pred2*3)<abs(pcr_pred1)) {pcr_pred2=predi(model,df,ncomp=tmpid)
    cnt=cnt+1}
    if(is.na(pcr_pred2)) {pcr_pred2=pcr_pred1}
    if(abs(pcr_pred2)>abs(pcr_pred1*3) || abs(pcr_pred2*3)<abs(pcr_pred1)) {
      pcr_pred2=pcr_pred1
    }
    model1res=append(model1res,pcr_pred1)
    model2res=append(model2res,pcr_pred2)
    idr=append(idr,i)
  }
  real=tuse[idr,1]
  low =0
  high =1
  eps = 1e6
  reclow=rechigh=0.5
  if(length(idr)>10)
  {
  a1=quantile(real,0.9)
  ids=which(real<=a1)
  model1res=model1res[ids]
  model2res=model2res[ids]
  real=real[ids]
  while (low<=1)
  {
    combined=model1res*low+model2res*high
    x=sum((combined-real)^2)/length(real)
  if (x <eps)
  { eps=x  
    reclow=low
    rechigh=high
  }
  low=low+0.01
  high=high-0.01
  }
  reclow=reclow+cnt/length(real)+trash/(ncol(t)-1)
  if(reclow>=1) reclow=1
  rechigh=1-reclow
  }
  }else{
    reclow=rechigh=0.5
  }
 
  #####
  #reclow=0.67
  #rechigh=0.33
  if(trash>0)
  {fil2=fil-1
  subdata=subdata[,fil2]
  }
  for(i in 1:length(lis))
  {
    id=lis[i]
    dist=c()
    recordid=c()
    for(j in 1:ncol(subdata))
    {
      # tmp=discal(id,subdata[,j])
      tmp=subdata[,j]
      if(length(tmp[is.na(tmp)])<length(tmp) && !is.na(tmp[id]))
      {
        dist=cbind(dist,tmp)
        recordid=append(recordid,j)
      }
    }
    if(length(dist)==0)
    {  pcr_pred=mean(as.numeric(subdata2[id,]),na.rm=T)
      pcr_pred=(pcr_pred-meand)/sdd
      impdata[id]=pcr_pred
    }
    if(length(dist)>0)
    {
    selectrows=c()
    for(k in 1:nrow(dist))
    {
      #print(k)
      tmp=dist[k,]
      if(!is.na(sum(tmp)) )
      {
        # a=allright(tmp)
        # if(a==1){ b=cbind(k,t(tmp))
        b=cbind(k,t(tmp))
        selectrows=rbind(selectrows,b)
        #}
      }
    }
    if(nrow(selectrows)<=ncol(subdata)*10)
    {
      for(k in 1:nrow(dist))
      {
        #print(k)
        tmp=dist[k,]
        if(length(which(is.na(tmp)))<length(tmp)*0.2)
        {
          # a=allright(tmp)
          # if(a==1){ b=cbind(k,t(tmp))
          tti=which(is.na(tmp))
          tmpmean=mean(tmp,na.rm=T)
          for(l in tti)
          {tmp[l]=tmpmean+runif(1,-1e-4,1e-4)}
          b=cbind(k,t(tmp))
          selectrows=rbind(selectrows,b)
          #}
        }
      }
    }
   
    y=data[selectrows[,1]]
    js=which(y %in% NA)
    x=data.frame(selectrows[,2:ncol(selectrows)])
    colnames(x)=colnames(subdata)[recordid]
    if(length(js)>0){
      x2=x[-js,]
      y2=y[-js]
    }else{
      x2=x
      y2=y
    }
    all=cbind(y2,x2)
    all=data.frame(all)
    df=data.frame(t(subdata[id,recordid]))
   
    corr=c()
    a=1:nrow(all)
    for(j in a)
    {
      tmpdf=as.numeric(df)
      tmp=as.numeric(all[j,2:ncol(all)])
      corr=rbind(corr,cbind(j,cor(tmpdf,tmp,method="pearson")))
    }
    subl=which(abs(corr[,2])>0.9)
    subl=corr[subl,1]
    if(length(subl)>0 && length(subl)<ncol(all)*10)
    {
      corrtmp=corr[order(abs(corr[,2]),decreasing = T),]
      if(nrow(corrtmp)>ncol(all)*10)
      {subl=corrtmp[1:(ncol(all)*10),1]
      }else{
        subl=corrtmp[,1]
      }
    }else
    {
      subl=corr[,1]
    }
    subl=sort(subl)
    all=all[subl,]
    all=data.frame(all)
    colnames(all)[1]="y2"
   
   
    #df=data.frame(t(subdata[id,(jjs-1)[2:6]]))
    if(ncol(df)==1) colnames(df)="x2"
    if(ncol(all)<=3 || nrow(all)<=ncol(all)*5){
      pcr_pred=mean(as.numeric(subdata2[id,]),na.rm=T)
      pcr_pred=(pcr_pred-meand)/sdd
    }else{
     
      distance=cor(all,all,method="pearson")
      distance=distance[1,2:ncol(distance)]
      tmpmax=max(df)
      tmpmin=min(df)
      if(ncol(all)>3 && tmpmin<=max(all)*2 && tmpmax>=min(all)*0.5 && nrow(all)>ncol(all)*5){
        #jsid=ncol(all)/2
        #model <- plsr(y2~., data=all,scale=T, validation="none")
        model <- pfit(y2~., data=all)
        class(model)="mvr"
        tmpall=as.numeric(model$Xvar)/model$Xtotvar
        tmpall2=tmpall
        tmpid=model$ncomp
        if(tmpid>2)
        {
          for(ttt in 2:model$ncomp)
          {
            if(is.na(tmpall2[ttt]))
          {break}
            tmpall2[ttt]=tmpall[ttt]+tmpall2[ttt-1]
            if(tmpall2[ttt]>=0.9) {
              tmpid=ttt
              break}
          }
        }
       
        if(tmpid<=2) tmpid=2
        pcr_pred2=10000
       
        #jsid=5
        jsid=tmpid
        #jsid=10
        tmpsort=sort(abs(distance),decreasing=T)[jsid]
        disname=colnames(all)[2:ncol(all)]
        trashdisname=disname[abs(distance)<tmpsort]
        distance[abs(distance)<tmpsort]=0
        distance=abs(distance)/sum(abs(distance))
        if(tmpid==2 && max(distance)>=0.8)
        {
          distance[distance<max(distance)]=0
          distance[distance>0]=1
          trashdisname=disname[abs(distance)<1]
        }
        #  pcr_pred=(sum(df*distance)+pcr_pred2)/2
        if(nrow(all)>=model$ncomp*ncol(all))
        {
          notall=all[,!colnames(all)%in%trashdisname]
          #model2=plsr(y2~., data=notall,scale=T, validation="none")
          model2=pfit(y2~., data=notall)
          class(model2)="mvr"
          notdf=df[,!disname%in%trashdisname]
          if(length(notdf)==1)
          {
            notdf=data.frame(notdf)
            tmpname=disname[!disname%in%trashdisname]
            colnames(notdf)=tmpname
          }
          tmpid2=model2$ncomp
          if(model2$ncomp>2)
          {
          tmpall=as.numeric(model2$Xvar)/model2$Xtotvar
         
          tmpall2=tmpall
          for(ttt in 2:model2$ncomp)
          {
            tmpall2[ttt]=tmpall[ttt]+tmpall2[ttt-1]
            if(is.na(tmpall2[ttt]))
               {
              tmpid2=ttt-1
              break}
              if(tmpall2[ttt]>=1) {
              tmpid2=ttt
              break}
          }
          }
          pcr_pred2 <- predi(model2, notdf,ncomp=tmpid2)
          tmp=sum(df*distance)
          if(is.na(pcr_pred2)) pcr_pred2=10000
          if(abs(pcr_pred2)>abs(tmp*2) || abs(pcr_pred2*2)<abs(tmp)) pcr_pred2=10000
        }
        if(pcr_pred2>=10000 && ncol(all)>=max(ncol(subdata2)/3,5))
        { pcr_pred=sum(df*distance)
        #model <- plsr(y2~., data=all,scale=T, validation="none")
        model <- pfit(y2~., data=all)
        class(model)="mvr"
        tmpall=as.numeric(model$Xvar)/model$Xtotvar
        tmpid=model$ncomp
        if(tmpid>2)
        {
        tmpall2=tmpall
        for(ttt in 2:model$ncomp)
        {
          tmpall2[ttt]=tmpall[ttt]+tmpall2[ttt-1]
          if(tmpall2[ttt]>=1) {
            tmpid=ttt
            break}
        }
        }
        pcr_pred2 <- predi(model, df,ncomp=tmpid)
        tmp=sum(df*distance)
        if(is.na(pcr_pred2) || pcr_pred2>1e3) {pcr_pred2=pcr_pred
        }else if(abs(pcr_pred2)>abs(tmp*3) || abs(pcr_pred2*3)<abs(tmp)) {pcr_pred2=pcr_pred
        }else {pcr_pred=(sum(df*distance)*reclow+pcr_pred2*rechigh)}
        }else if(pcr_pred2>=10000 && ncol(all)<max(ncol(subdata2)/3,5)){
          pcr_pred=sum(df*distance)
        }else{
          pcr_pred=(sum(df*distance)*reclow+pcr_pred2*rechigh)
        }
       
      }else{
        distance=abs(distance)/sum(abs(distance))
        pcr_pred=sum(df*distance)
      }
    }
    # relation=lm(y2~.,data=all)
    impdata[id]=pcr_pred
    }
  }
  impdata2=impdata
  if(flag==-1)
  {
    tmpmin=min(data,na.rm=T)
    for(i in 1:length(lis))
    {
      id=lis[i]
      por=length(impdata[impdata<=impdata[id]])/length(impdata)
      tpor=length(impdata[impdata<=tmpmin])/length(impdata)
      allmin=min(c(subdata,data),na.rm=T)
      if(por >tpor)
      {
        impdata2[id]=runif(1,allmin,tmpmin)
      }
     
    }
  }
  return(list(imp.data=impdata2,mislis=lis,meand=meand,sdd=sdd,restsubmeta1=subdata))
}

```

#evaluation

```{r}
#NRMSE
nrmse1 <- function(data_imp, data_true) {
  sum=0
    for(i in 1:nrow(data_true))
    {
    for(j in 1:ncol(data_true))
    {
    sum=sum+(as.numeric(data_true[i,j])-as.numeric(data_imp[i,j]))^2
    if(is.na(sum)) break
    }
    }
  
  sum=sum/(nrow(data_true)*ncol(data_true))
  sum=sqrt(sum)
  sum=sum/sd(as.numeric(as.matrix(data_true)))
  return (sum)
}

```

#other MVI methods
mean

```{r}
Mean_wrapper <- function(data) {
  result = data
  result = apply(result,2, function(x) 
  {
    x[is.na(x)] = mean(x, na.rm = T)
    x
  })
  return(result)
}
```

median

```{r}
Median_wrapper <- function(data) {
  result = data
  result = apply(result,2, function(x) 
  {
    x[is.na(x)] = median(x, na.rm = T)
    x
  })
  return(result)
}
```

QRILC (Quantile regression approach for left-censored missing)

```{r}
QRILC_wrapper <- function(data) 
{
  data_raw = t(data)
  data_raw_log_qrilc = impute.QRILC(data_raw)[[1]]
  result =data_raw_log_qrilc
  for(i in 1:nrow(result))
  {
    for (j in 1:ncol(result))
    {
      if(as.numeric(result[i,j])>10) result[i,j]=10
      if(as.numeric(result[i,j])<(-10)) result[i,j]=-10
    }
  }
  return(t(result))
}

```

KNN

```{r}
KNN_wrapper<-function(data)
{
  data=data
  res=impute.knn(data,k = 10, rowmax = 0.8, colmax = 0.99, maxp = 1500, rng.seed=100)
  t=res$data
  t=t
  return (t)
}
```

PPCA

```{r}
PPCA_wrapper <- function(data,i) 
{
  data_raw = data
  if(nrow(data)>10)
  result =  pca(data_raw, method="ppca", threshold=1e-05,center=FALSE, nPcs=10)
  else 
  result =  pca(data_raw, method="ppca", threshold=1e-05, center=FALSE, nPcs=2)
  cbs = completeObs(result)
  for(i in 1:nrow(cbs))
  {
    for (j in 1:ncol(cbs))
    {
      if(as.numeric(cbs[i,j])>10) cbs[i,j]=10
      if(as.numeric(cbs[i,j])<(-10)) cbs[i,j]=-10
    }
  }
  return(cbs)
}

```

BPCA

```{r}
BPCA_wrapper <- function(data) 
{
  data_raw = data
  if(nrow(data)>5 && ncol(data)>5)
  result =  pca(data_raw, method="bpca", threshold=1e-05,center=FALSE, nPcs=nrow(data)-3,maxSteps = 300)
  else 
  result =  pca(data_raw, method="bpca", threshold=1e-05,center=FALSE, nPcs=2,maxSteps = 300)
  cbs = completeObs(result)
  for(i in 1:nrow(cbs))
  {
    for (j in 1:ncol(cbs))
    {
      if(as.numeric(cbs[i,j])>10) cbs[i,j]=10
      if(as.numeric(cbs[i,j])<(-10)) cbs[i,j]=-10
    }
  }
  return(cbs)
}
```

LLS

```{r}
LLS_wrapper <- function(data) 
{
  data_raw = t(data)
  if(ncol(data_raw)<10) {result=llsImpute(data_raw, k = floor(ncol(data_raw)*0.5), correlation="pearson", allVariables=TRUE, maxSteps=100)}
  else {result=llsImpute(data_raw, k = 10, correlation="pearson", allVariables=TRUE, maxSteps=100)}
  cbs = completeObs(result)
  #write.csv(cbs,"1.csv")
  for(i in 1:nrow(cbs))
  {
    for (j in 1:ncol(cbs))
    {
      if(as.numeric(cbs[i,j])>10) cbs[i,j]=10
      if(as.numeric(cbs[i,j])<(-10)) cbs[i,j]=-10
    }
  }
  return(t(cbs))
}
```

EM

```{r}
#pure EM
svdwrapper = function( x,  nu = min(nrow(x), ncol(x)), nv = min(nrow(x), ncol(x)), verbose=T ){
  #   Caution: I have not tested this much.
  #   It's here as an example for an R-Help discussion.
  gotit = F
  try( {svdx = svd(x,nu,nv); gotit=T}, silent = !verbose )
  if( gotit )return(svdx)
  try( {svdtx = svd(t(x),nv,nu); gotit=T}, silent = !verbose )
  if( !gotit ){stop("svd(x) and svd(t(x)) both failed.")
    }
  if( verbose )print("svd(x) failed but svd(t(x)) worked.")
  temp    = svdtx$u
  svdtx$u = svdtx$v
  svdtx$v = temp
  svdtx
}
PEMM_fu=function (X, phi, lambda = NULL, K = NULL, pos = NULL, tol = 0.01, 
    maxIter = 100) 
{
  
    get.llik <- function(X, mu, S, phi, phi0) {
        if (length(which(X < 0)) == 0) 
            pos <- TRUE
        else pos <- FALSE
        llik <- 0
        for (j in 1:nrow(X)) {
            Xi <- X[j, ]
            idxi <- which(!is.na(Xi))
            Xi <- Xi[idxi]
            Si <- as.matrix(S[idxi, idxi])
            Sii <- my.solve(Si)
            #if(is.na(Sii)) return(NA)
            oo <- -log(det(Si)) - (Xi - mu[idxi]) %*% Sii %*% 
                (Xi - mu[idxi])
            oo <- 0.5 * oo
            nmis <- length(X[j, ]) - length(idxi)
            if (phi == 0) {
                vv <- 0
            }
            else {
                if (pos) {
                  vv1 = sum(log(1 - exp(-phi0 - phi * Xi)))
                  vv2 <- -phi0 * nmis
                  if (nmis == 0) {
                    vv3 <- 0
                  }
                  else {
                    Smi <- as.matrix(S[-idxi, -idxi])
                    mu.mis <- mu[-idxi] + matrix(S[-idxi, idxi], 
                      nrow = nmis) %*% Sii %*% (Xi - mu[idxi])
                    S.mis <- Smi - matrix(S[-idxi, idxi], nrow = nmis) %*% 
                      Sii %*% matrix(S[idxi, -idxi], ncol = nmis)
                    vv3 <- -sum(mu.mis) * phi + 0.5 * sum(S.mis) * 
                      phi^2
                  }
                  vv <- vv1 + vv2 + vv3
                }
                else {
                  vv1 = sum(log(1 - exp(-phi0 - phi * Xi^2)))
                  vv2 <- -phi0 * nmis
                  if (nmis == 0) {
                    vv3 <- 0
                  }
                  else {
                    Smi <- as.matrix(S[-idxi, -idxi])
                    mu.mis <- mu[-idxi] + matrix(S[-idxi, idxi], 
                      nrow = nmis) %*% Sii %*% (Xi - mu[idxi])
                    S.mis <- Smi - matrix(S[-idxi, idxi], nrow = nmis) %*% 
                      Sii %*% matrix(S[idxi, -idxi], ncol = nmis)
                    Smis.inv <- my.solve(S.mis)
                    #if(is.na(Smis.inv)) return(NA)
                    Smii <- Smis.inv
                    diag(Smis.inv) <- diag(Smis.inv) + 2 * phi
                    A <- my.solve(Smis.inv)
                    #if(is.na(A)) return (NA)
                    vv3 <- 0.5 * (log(det(A)) - log(det(S.mis)) + 
                      matrix(mu.mis, nrow = 1) %*% (Smii %*% 
                        A %*% Smii - Smii) %*% matrix(mu.mis, 
                        ncol = 1))
                  }
                  vv <- vv1 + vv2 + vv3
                }
            }
            llik <- llik + oo + vv
        }
        pllik <- llik
        return(llik)
    }
    my.solve <- function(X) {
        if (!is.matrix(X)) 
            X <- matrix(X, nrow = sqrt(length(X)))
        ss <- svdwrapper(X)
        #if(is.na(ss)) return (NA)
        Xinv <- ss$u %*% diag(1/ss$d, nrow = nrow(X), ncol = nrow(X)) %*% 
            t(ss$v)
        return(Xinv)
    }
    gets1 <- function(sigma, phi) {
        p <- nrow(sigma)
        #if(is.na(my.solve(sigma))) return(NA)
        s1 <- my.solve(sigma) + diag(2 * phi, p, p)
        return(s1)
    }
    get.bg <- function(sigma, mu, phi) {
        p <- length(mu)
        s1 <- gets1(sigma, phi)
        #if(is.na(s1)) return(NA)
        s1inv <- my.solve(s1)
        ccen <- my.solve(sigma)
        #if(is.na(s1inv)) return (NA)
        #if(is.na(ccen)) return (NA)
        A <- s1inv %*% ccen
        beta <- A %*% mu
        gamma <- s1inv
        return(list(beta = beta, gamma = gamma))
    }
    find.lambda <- function(Sigma, N, p, K, delta = delta) {
        ffL <- function(lambda, Sigma, N, p, K) {
            Sigma.new <- N/(N + K) * Sigma * (N - 1)/N + lambda/(N + 
                K) * diag(1, p, p)
            return(abs(min(as.double(eigen(N * Sigma.new)$value))))
        }
        Sigma2 = Sigma
        while (!is.double(eigen(N * Sigma2)$value)) {
            delta = delta + 1
            Sigma2 = N/(N + K) * Sigma * (N - 1)/N + delta/(N + 
                K) * diag(1, p, p)
        }
        Sigma = Sigma2
        oo <- -min(as.double(eigen(N * Sigma)$value))
        if (oo > 0) {
            lambda <- optimize(ffL, lower = 0, upper = oo, Sigma = Sigma, 
                N = N, p = p, K = K)$minimum + delta
        }
        else {
            lambda <- delta
        }
        return(lambda)
    }
    if (is.null(pos)) {
        if (length(which(X < 0)) == 0) 
            pos <- TRUE
        else pos <- FALSE
    }
    if (phi == 0) {
        phi0 <- -log(mean(is.na(X)))
    }
    else {
        phi0 <- 0
    }
    p <- ncol(X)
    N <- nrow(X)
    if (is.null(K)) {
        K = 5
    }
    
    
    
    X.hat <- X
    mu.new <- matrix(colMeans(X, na.rm = T), ncol = 1)
    Sigma.new <- cov(X, use = "pairwise.complete")
    Sigma.new[is.na(Sigma.new)] <- 0
    diff <- 999
    iter <- 0
    if (is.null(lambda)) {
        delta = 5
        Lambda <- find.lambda(Sigma.new, N = N, p = p, K = K, 
            delta = delta)
    }
    else {
        Lambda <- lambda
    }
    Sigma.new <- N/(N + K) * Sigma.new * (N - 1)/N + Lambda/(N + 
        K) * diag(1, p, p)
    illik <- 999
    while (iter < maxIter & diff > tol) {
      print(iter)
        iter <- iter + 1
        mu <- mu.new
        Sigma <- Sigma.new
        cov.add <- matrix(0, p, p)
        for (i in 1:nrow(X)) {
            ii <- which(is.na(X[i, ]))
            if (length(ii) >= 1) {
                Soo <- as.matrix(Sigma[-ii, -ii])
                pi <- nrow(Soo)
                #if(is.na(my.solve(Soo))) return (NA)
                mu.mis <- mu[ii] + Sigma[ii, -ii] %*% my.solve(Soo) %*% 
                  (X[i, -ii] - mu[-ii])
                mu.mis <- matrix(mu.mis, ncol = 1)
                cov.mis <- Sigma[ii, ii] - Sigma[ii, -ii] %*% 
                  my.solve(Soo) %*% Sigma[-ii, ii]
                if (phi != 0 & pos == TRUE) {
                  X.hat[i, ii] <- mu.mis - phi * cov.mis %*% 
                    matrix(1, nrow = length(mu.mis), ncol = 1)
                  cov.ii <- cov.mis
                }
                else if (phi != 0 & pos == FALSE) {
                  oo <- get.bg(cov.mis, mu.mis, phi)
                  #if(is.na(oo)) return (NA)
                  X.hat[i, ii] <- oo$beta
                  cov.ii <- oo$gamma
                }
                else if (phi == 0) {
                  X.hat[i, ii] <- mu.mis
                  cov.ii <- cov.mis
                }
                cov.add[ii, ii] <- cov.add[ii, ii] + cov.ii
            }
        }
        mu.new <- colMeans(X.hat)
        Sig <- cov(X.hat) * (N - 1)/N + cov.add/N
        if (is.null(lambda)) {
            Lambda <- find.lambda(Sig, N = N, p = p, K = K, delta = delta)
        }
        else {
            Lambda <- lambda
        }
        Sigma.new <- N/(N + K) * (Sig) + Lambda/(N + K) * diag(1, 
            p, p)
        #if(is.na(my.solve(Sigma.new))) return (NA)
        #if(is.na(get.llik(X, mu.new, Sigma.new, phi = phi, 
        #    phi0 = phi0))) return (NA)
        illik <- c(illik, get.llik(X, mu.new, Sigma.new, phi = phi, 
            phi0 = phi0) - sum(diag(Lambda * my.solve(Sigma.new))) - 
            K * log(det(Sigma.new)))
        diff <- abs(illik[iter + 1] - illik[iter])/abs(illik[iter])
        if (is.na(diff)) {
            diff <- 0
            warning("The algorithm does not converge!")
        }
    }
    if (iter == maxIter) 
        warning("The algorithm does not converge!")
    return(list(mu = mu, Sigma = Sigma, Xhat = X.hat))
}
EM_wrapper <- function(data) 
{
  data_raw = as.matrix(data)
  result=PEMM_fun(data_raw, phi=0 ,lambda=0, K=0)
  #if(is.na(result)) return (NA)
  return(result$Xhat)
}
#for MAR, pennalized EM
PEM_wrapper <- function(data) 
{
  data_raw = as.matrix(data)
  result=PEMM_fu(data_raw, phi=0, tol=0.01,maxIter = 100)
  #if(is.na(result)) return (NA)
  return(result$Xhat)
}
#for MNAR
PEMM_wrapper <- function(data) 
{
  data_raw = as.matrix(data)
  result=PEMM_fun(data_raw, phi=1)
  #if(is.na(result)) return (NA)
  #for(i in 1:nrow(result))
  #{
  #  for (j in 1:ncol(result))
  #  {
  #    if(as.numeric(result[i,j])>10) result[i,j]=10
  #    if(as.numeric(result[i,j])<(-10)) result[i,j]=-10
  #  }
  #}
  return(result$Xhat)
}
```

KNN-TN

```{r}
mklhood <- function(data, t, ...) {
  
  data <- na.omit(data)
  n <- length(data)
  t <- sort(t)
  
  psi<-function(y, mu, sigma){
    exp(-(y-mu)^2/(2*sigma^2))/(sigma*sqrt(2*pi))
  }
  
  psi.mu<-function(y,mu,sigma){
    exp(-(y-mu)^2/(2*sigma^2)) * ((y-mu)/(sigma^3*sqrt(2*pi)))
  }
  
  psi.sigma<-function(y,mu,sigma){
    exp(-(y-mu)^2/(2*sigma^2)) *
      (((y-mu)^2)/(sigma^4*sqrt(2*pi)) - 1/(sigma^2*sqrt(2*pi)))
  }
  
  psi2.mu<-function(y,mu,sigma){
    exp(-(y - mu)^2/(2*sigma^2)) *
      (((y - mu)^2)/(sigma^5*sqrt(2*pi))-1/(sigma^3*sqrt(2*pi)))
  }
  
  psi2.sigma<-function(y,mu,sigma){
    exp(-(y-mu)^2/(2*sigma^2)) *
      ((2)/(sigma^3*sqrt(2*pi)) - (5*(y-mu))/(sigma^5*sqrt(2*pi)) +
         ((y-mu)^4)/(sigma^7*sqrt(2*pi)))
  }
  
  psi12.musig<-function(y,mu,sigma){
    exp(-(y-mu)^2/(2*sigma^2)) *
      (((y-mu)^3)/(sigma^6*sqrt(2*pi)) - (3*(y-mu))/(sigma^4*sqrt(2*pi)))
  }
  
  ll.tnorm2<-function(p){
    out <- (-n*log(pnorm(t[2],p[1],p[2])-pnorm(t[1],p[1],p[2]))) -
      (n*log(sqrt(2*pi*p[2]^2))) - (sum((data-p[1])^2)/(2*p[2]^2))
    -1*out
  }
  
  grad.tnorm<-function(p){
    g1 <- (-n*(integrate(psi.mu,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value) /
             (pnorm(max(t),p[1],p[2])-pnorm(min(t),p[1],p[2]))) - ((n*p[1]-sum(data))/p[2]^2)
    g2 <- (-n*(integrate(psi.sigma,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value) /
             (pnorm(max(t),p[1],p[2])-pnorm(min(t),p[1],p[2]))) - ((n)/(p[2])) + ((sum((data-p[1])^2))/(p[2]^3))
    out <- c(g1,g2)
    return(out)
  }
  
  hessian.tnorm<-function(p){
    
    h1<- -n*(integrate(psi,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value *
               integrate(psi2.mu,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value -
               integrate(psi.mu,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value^2) /
      (integrate(psi,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value^2) -
      n/(p[2]^2)
    
    h3<- -n*(integrate(psi,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value *
               integrate(psi12.musig,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value -
               integrate(psi.mu,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value *
               integrate(psi.sigma,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value) /
      (integrate(psi,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value^2) +
      (2*(n*p[1]-sum(data)))/(p[2]^3)
    
    h2<- -n*(integrate(psi,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value *
               integrate(psi2.sigma,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value -
               integrate(psi.sigma,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value^2) /
      (integrate(psi,t[1],t[2],mu=p[1],sigma=p[2], stop.on.error = FALSE)$value^2) +
      (n)/(p[2]^2)-(3*sum((data-p[1])^2))/(p[2]^4)
    
    H<-matrix(0,nrow=2,ncol=2)
    H[1,1]<-h1
    H[2,2]<-h2
    H[1,2]<-H[2,1]<-h3
    return(H)
  }
  
  
  return(list(ll.tnorm2 = ll.tnorm2, grad.tnorm = grad.tnorm, hessian.tnorm = hessian.tnorm))
}
EstimatesComputation <- function(missingdata, perc, iter=50) {
  
  ## 2 column matrix where column 1 = means, column 2 = SD
  ParamEstim <- matrix(NA, nrow = nrow(missingdata), ncol = 2)
  nsamp <- ncol(missingdata)
  
  ## sample means / SDs
  ParamEstim[,1] <- rowMeans(missingdata, na.rm = TRUE)
  ParamEstim[,2] <- apply(missingdata, 1, function(x) sd(x, na.rm = TRUE))
  
  ## Case 1: missing % > perc => use sample mean / SD
  na.sum <- apply(missingdata, 1, function(x) sum(is.na(x)))
  idx1 <- which(na.sum/nsamp >= perc)
  
  ## Case 2: sample mean > 3 SD away from LOD => use sample mean / SD
  lod <- min(missingdata, na.rm=TRUE)
  idx2 <- which(ParamEstim[,1] > 3*ParamEstim[,2] + lod)
  
  ## Case 3: for all others, use NR method to obtain truncated mean / SD estimate
  idx.nr <- setdiff(1:nrow(missingdata), c(idx1, idx2))
  ## t = limits of integration (LOD and upper)
  upplim <- max(missingdata, na.rm=TRUE) + 2*max(ParamEstim[,2])
  for (i in idx.nr) {
    Likelihood <- mklhood(missingdata[i,], t=c(lod, upplim))
    res <- tryCatch(NewtonRaphsonLike(Likelihood, p = ParamEstim[i,]),
                    error = function(e) 1000)
    
    if (length(res) == 1) {
      next
    } else if (res$iter >= iter) {
      next
    } else {
      ParamEstim[i,] <- as.numeric(res$estimate)
    }
  }
  return(ParamEstim)
}

imputeKNN <- function (data, k , distance = "correlation",
                       rm.na = TRUE, rm.nan = TRUE, rm.inf = TRUE, perc=1,...) {
  
  if (!(is.matrix(data))) {
    stop(message = paste(deparse(substitute(data)),
                         " is not a matrix.", sep = ""))
  }
  for(i in 1:nrow(data))
  {
    countp=length(which(is.na(data[i,])))
    if(countp >= ncol(data)*0.8)
    {
      med=mean(data[i,],na.rm=T)
      for(j in 1:ncol(data))
      {
        if(is.na(data[i,j]))
        data[i,j]=med+runif(1,-1e-3,1e-3)
      }
    }
  }
  distance <- match.arg(distance, c("correlation","truncation"))
  
  nr <- dim(data)[1]
  if (k < 1 | k > nr) {
    stop(message = "k should be between 1 and the number of rows")
  }
  
  if (distance=="correlation"){
    genemeans<-rowMeans(data,na.rm=TRUE)
    genesd<-apply(data, 1, function(x) sd(x, na.rm = TRUE))
    data<-(data-genemeans)/genesd
  }
  
  if (distance=="truncation"){
    
    ParamMat <- EstimatesComputation(data, perc = perc)
    
    genemeans<-ParamMat[,1]
    genesd<-ParamMat[,2]
    data<-(data-genemeans)/genesd
  }
  
  imp.knn <- data
  imp.knn[is.finite(data) == FALSE] <- NA
  t.data<-t(data)
  
  mv.ind <- which(is.na(imp.knn), arr.ind = TRUE)
  arrays <- unique(mv.ind[, 2])
  array.ind <- match(arrays, mv.ind[, 2])
  ngenes <- 1:nr

      for (i in 1:length(arrays)) {
        set <- array.ind[i]:min((array.ind[(i + 1)] - 1), dim(mv.ind)[1],
                                na.rm = TRUE)
        cand.genes <- ngenes[-unique(mv.ind[set, 1])]
        cand.vectors <- t.data[,cand.genes]
        exp.num<- arrays[i]
        for (j in set) {

            gene.num <- mv.ind[j, 1]
            tar.vector <- data[gene.num,]

            r <- (cor(cand.vectors,tar.vector, use = "pairwise.complete.obs"))
            dist <- switch(distance,
                           correlation = (1 - abs(r)),
                           truncation = (1 - abs(r)))
            dist[is.nan(dist) | is.na(dist)] <- Inf
            dist[dist==0]<-ifelse(is.finite(min(dist[dist>0])), min(dist[dist>0])/2, 1)
            dist[abs(r) == 1] <- Inf

            if (sum(is.finite(dist)) < k) {
                stop(message = "Fewer than K finite distances found")
            }
            k.genes.ind <- order(dist)[1:k]
            k.genes <- cand.genes[k.genes.ind]

            wghts <- (1/dist[k.genes.ind]/sum(1/dist[k.genes.ind])) * sign(r[k.genes.ind])
            imp.knn[gene.num, exp.num] <- wghts %*% data[k.genes, exp.num]
        }
    }
  if (distance=="correlation") {
    imp.knn <- (imp.knn * genesd) + genemeans
  }
  
  if(distance=="truncation") {
    imp.knn <- (imp.knn * genesd) + genemeans
  }
  
  if (!rm.na) {
    imp.knn[is.na(data) == TRUE & is.nan(data) == FALSE] <- NA
  }
  if (!rm.inf) {
    index <- is.finite(data) == FALSE & is.na(data) == FALSE &
      is.nan(data) == FALSE
    imp.knn[index] <- data[index]
  }
  if (!rm.nan) {
    imp.knn[is.nan(data) == TRUE] <- NaN
  }
  return(imp.knn)
}
```

#dataset with simulation-MCAR+MNAR
```{r}
allresult=c()
allresultpro=c()
RCCC<- read.delim("RC_original.txt", header= TRUE, sep="\t")
  RCC=RCCC
for(qq in seq(0.1,0.4,0.1))
{
  tf=qq/5
for(rd in seq(0,qq,tf))
{
 
  for(iterr in 1:5)
  {
subRC=c()
for(i in 1:nrow(RCC))
{
  if(!is.na(sum(RCC[i,])))
  {
    subRC=rbind(subRC,RCC[i,])
  }
}
subRCa=subRC
rownames(subRC)=c(1:nrow(subRC))
RC2=subRCa

subRChole=c()
for(number in 1:24)
{
  set.seed(number+iterr)
  mis_prop=qq-rd
  data_res = RC2[,number]
  a=data_res
  if(mis_prop!=0)
  {
    cutoff = quantile(a, mis_prop,na.rm=T)
    a[a< cutoff] = NA
    data_res=a
  }
  
  mis_prop=rd
  q=round(length(data_res)*mis_prop)
  tmplis=which(!is.na(data_res))
  mi = sample(tmplis, q)
  data_res[mi] = NA
  
  subRChole=cbind(subRChole,data_res)
}
colnames(subRChole)=colnames(subRCa)
jid=c()
for(j in 1:nrow(subRChole))
{
  tmp=subRChole[j,]
  ge=tmp[is.na(tmp)]
  if(length(ge)==ncol(subRChole))
    jid=append(jid,j)
}
if(length(jid)>=1)
{
  RC2=RC2[-jid,]
  subRChole=subRChole[-jid,]
}
RC=subRChole
impdataall0=c()
projectfinal0=c()
impdataall=c()
projectfinal=c()
for(number in 1:24)
{
RCN1=log(RC[,number])
rownames(RCN1)=rownames(RC)
RCN1final=RCN1
restRC=cbind(RC[,-number])
restRC1=log(restRC)
rownames(restRC1)=rownames(RC)
    if(abs(rd-qq)<1e-4)
      {impRC=initial(RCN1, restRC1,0)#same as else
    } else if(abs(rd)<1e-4)
      {impRC=initial(RCN1, restRC1,-1)
    }else{
      impRC=initial(RCN1, restRC1)
    }
misid=impRC$mislis
impdata=impRC$imp.data
  meand=impRC$meand
    sdd=impRC$sdd
    RCN2=(RCN1-meand)/sdd
    RCN1final=RCN2
    restRC2=impRC$restsubmeta1
    
    impdatall0=cbind(impdataall0,impdata)
    imptmp=exp(impdata * sdd + meand)
    impdataall=cbind(impdataall,imptmp)
  #rec=append(rec,y2$rec)
}
#rec=unique(rec)
#rec=rec[rec!=0]
    colnames(impdataall)=colnames(subRChole)
    mislis=list()
   
scaleRC=scale(log(subRChole))
RCNt=t(scaleRC)
m1=Mean_wrapper(RCNt)
m2=QRILC_wrapper(RCNt)
m3=KNN_wrapper(RCNt)
m4=PPCA_wrapper(RCNt)
m5=BPCA_wrapper(RCNt)
m6=LLS_wrapper(t(RCNt))
m7=imputeKNN(t(RCNt), k=10 , distance = "truncation", perc= 0.75)
mislis[[1]]=m1
mislis[[2]]=m2
mislis[[3]]=m3
mislis[[4]]=m4
mislis[[5]]=m5
mislis[[6]]=t(m6)
mislis[[7]]=t(m7)
unlis=list()
length(unlis)=7

for(i in 1:7)
{
  tmp=t(mislis[[i]])
      res=c()
      for(j in 1:ncol(subRChole))
      {
      a=subRChole[,j]
      b=log(a)
      c=scale(b)
      tmpres=exp(tmp[,j] * attr(c, 'scaled:scale') + attr(c, 'scaled:center'))
      res=cbind(res,tmpres)
      }
      colnames(res)=colnames(subRChole)
      unlis[[i]]=res
      
}
nrmselis=list()
length(nrmselis)=8
for(i in 1:7)
{
  nrmselis[[i]]=nrmse1(unlis[[i]],RC2)
}
 nrmselis[[8]]=nrmse1(impdataall,RC2)
g=as.data.frame(nrmselis)
#print(g)
colnames(g)=c("mean","QRILC","KNN","PPCA","BPCA","LLS","KNN-TN","impdata")
allresult=rbind(allresult,g)
proclis=list()
length(proclis)=8
for(i in 1:8)
{
  if(i==8) pca_test=rda(impdataall, scale = TRUE)
  #if(i==9) pca_test=rda(projectfinal,scale=T)
  if(i<8) pca_test=rda(unlis[[i]], scale = TRUE)
      #myunlis
      pca_real=rda(RC2,scale=TRUE)
      site_test=summary(pca_test, scaling = 1)$site
      site_real=summary(pca_real, scaling = 1)$site
      proc=procrustes(X = site_real, Y = site_test, symmetric = T)
      proclis[[i]]=proc$ss
}
h=as.data.frame(proclis)
#print(g)
colnames(h)=c("mean","QRILC","KNN","PPCA","BPCA","LLS","KNN-TN","impdata")
allresultpro=rbind(allresultpro,h)
mixlis=list()
for(i in 1:7)
{
  mixlis[i]=unlis[i]
}
mixlis[[8]]=impdataall
mixlis[[9]]=RC2
names(mixlis)=c("mean","QRILC","KNN","PPCA","BPCA","LLS","KNN-TN","impdata","original")
write.xlsx(mixlis,paste0("rcall",qq,"_",rd,"_",iterr,".xlsx"))
  }
}
}
write.csv(allresult,"rcallnrmse.csv")
write.csv(allresultpro,"rcallpro.csv")

```
#dataset with simulation-MAR+MNAR
```{r}
allresult=c()
allresultpro=c()
RCCC<- read.delim("RC_original.txt", header= TRUE, sep="\t")
  RCC=RCCC
for(qq in seq(0.1,0.4,0.1))
{
  tf=qq/5
for(rd in seq(0,qq,tf))
{
 
  for(iterr in 1:5)
  {
subRC=c()
for(i in 1:nrow(RCC))
{
  if(!is.na(sum(RCC[i,])))
  {
    subRC=rbind(subRC,RCC[i,])
  }
}
subRCa=subRC
rownames(subRC)=c(1:nrow(subRC))
RC2=subRCa

subRChole=c()
set.seed(1+qq+rd+iterr)
sets=list()
sets[[1]]=sample(1:nrow(RC2),nrow(RC2)/2)
set.seed(2+qq+rd+iterr)
sets[[2]]=sample(1:nrow(RC2),nrow(RC2)/2)
set.seed(3++qq+rd+iterr)
sets[[3]]=sample(1:nrow(RC2),nrow(RC2)/2)
set.seed(4++qq+rd+iterr)
sets[[4]]=sample(1:nrow(RC2),nrow(RC2)/2)
for(number in 1:24)
{
  set.seed(number+iterr)
  mis_prop=qq-rd
  data_res = RC2[,number]
  a=data_res
  if(mis_prop!=0)
  {
    cutoff = quantile(a, mis_prop,na.rm=T)
    a[a< cutoff] = NA
    data_res=a
  }
  
  mis_prop=rd
  q=round(length(data_res)*mis_prop)
  tmplis=which(!is.na(data_res))
  tmpsid=sets[[as.integer((number-1)/6)+1]]
  tmplis=intersect(tmplis,tmpsid)
  mi = sample(tmplis, q)
  data_res[mi] = NA
  
  subRChole=cbind(subRChole,data_res)
}
colnames(subRChole)=colnames(subRCa)
jid=c()
for(j in 1:nrow(subRChole))
{
  tmp=subRChole[j,]
  ge=tmp[is.na(tmp)]
  if(length(ge)==ncol(subRChole))
    jid=append(jid,j)
}
if(length(jid)>=1)
{
  RC2=RC2[-jid,]
  subRChole=subRChole[-jid,]
}
RC=subRChole
impdataall0=c()
projectfinal0=c()
impdataall=c()
projectfinal=c()
for(number in 1:24)
{
RCN1=log(RC[,number])
rownames(RCN1)=rownames(RC)
RCN1final=RCN1
restRC=cbind(RC[,-number])
restRC1=log(restRC)
rownames(restRC1)=rownames(RC)
    if(abs(rd-qq)<1e-4)
      {impRC=initial(RCN1, restRC1,0)
    } else if(abs(rd)<1e-4)
      {impRC=initial(RCN1, restRC1,-1)
    }else{
      impRC=initial(RCN1, restRC1)
    }
misid=impRC$mislis
impdata=impRC$imp.data
  meand=impRC$meand
    sdd=impRC$sdd
    RCN2=(RCN1-meand)/sdd
    RCN1final=RCN2
    restRC2=impRC$restsubmeta1
    
    impdatall0=cbind(impdataall0,impdata)
    imptmp=exp(impdata * sdd + meand)
    impdataall=cbind(impdataall,imptmp)
  #rec=append(rec,y2$rec)
}
#rec=unique(rec)
#rec=rec[rec!=0]
    colnames(impdataall)=colnames(subRChole)
    mislis=list()
   
scaleRC=scale(log(subRChole))
RCNt=t(scaleRC)
m1=Mean_wrapper(RCNt)
m2=QRILC_wrapper(RCNt)
m3=KNN_wrapper(RCNt)
m4=PPCA_wrapper(RCNt)
m5=BPCA_wrapper(RCNt)
m6=LLS_wrapper(t(RCNt))
m7=imputeKNN(t(RCNt), k=10 , distance = "truncation", perc= 0.75)
mislis[[1]]=m1
mislis[[2]]=m2
mislis[[3]]=m3
mislis[[4]]=m4
mislis[[5]]=m5
mislis[[6]]=t(m6)
mislis[[7]]=t(m7)
unlis=list()
length(unlis)=7

for(i in 1:7)
{
  tmp=t(mislis[[i]])
      res=c()
      for(j in 1:ncol(subRChole))
      {
      a=subRChole[,j]
      b=log(a)
      c=scale(b)
      tmpres=exp(tmp[,j] * attr(c, 'scaled:scale') + attr(c, 'scaled:center'))
      res=cbind(res,tmpres)
      }
      colnames(res)=colnames(subRChole)
      unlis[[i]]=res
      
}
nrmselis=list()
length(nrmselis)=8
for(i in 1:7)
{
  nrmselis[[i]]=nrmse1(unlis[[i]],RC2)
}
 nrmselis[[8]]=nrmse1(impdataall,RC2)
g=as.data.frame(nrmselis)
#print(g)
colnames(g)=c("mean","QRILC","KNN","PPCA","BPCA","LLS","KNN-TN","impdata")
allresult=rbind(allresult,g)
proclis=list()
length(proclis)=8
for(i in 1:8)
{
  if(i==8) pca_test=rda(impdataall, scale = TRUE)
  #if(i==9) pca_test=rda(projectfinal,scale=T)
  if(i<8) pca_test=rda(unlis[[i]], scale = TRUE)
      #myunlis
      pca_real=rda(RC2,scale=TRUE)
      site_test=summary(pca_test, scaling = 1)$site
      site_real=summary(pca_real, scaling = 1)$site
      proc=procrustes(X = site_real, Y = site_test, symmetric = T)
      proclis[[i]]=proc$ss
}
h=as.data.frame(proclis)
#print(g)
colnames(h)=c("mean","QRILC","KNN","PPCA","BPCA","LLS","KNN-TN","impdata")
allresultpro=rbind(allresultpro,h)
mixlis=list()
for(i in 1:7)
{
  mixlis[i]=unlis[i]
}
mixlis[[8]]=impdataall
mixlis[[9]]=RC2
names(mixlis)=c("mean","QRILC","KNN","PPCA","BPCA","LLS","KNN-TN","impdata","original")
write.xlsx(mixlis,paste0("rcallmar",qq,"_",rd,"_",iterr,".xlsx"))
  }
}
}
write.csv(allresult,"rcallnrmsemar.csv")
write.csv(allresultpro,"rcallpromar.csv")
```
#cor
```{r}
res=c()
for(qq in seq(0.1,0.4,0.1))
{
  tf=qq/5
  for(rd in seq(0,qq,tf))
  {
    for(i in 1:8)
    {
      tmpres=c()
      for(iterr in 1:5)
      {
        c=paste0("rcallmar",qq,"_",rd,"_",iterr,".xlsx")
        RC2=read.xlsx(c,sheet=9)
        #group_factor=c(rep('Normal',6),rep('Cancer',6),rep('Normal',6),rep('Cancer',6))
        #group_factor=c(rep('Normal',8),rep('Cancer',8))
        rownames(RC2)=c(1:nrow(RC2))
        
        unlis=list()
        length(unlis)=8
        c=paste0("rcallmar",qq,"_",rd,"_",iterr,".xlsx")
        
        unlis[[i]]=read.xlsx(c,sheet=i)
        
        tmp=unlis[[i]]
        tmpcor=0
        for(k in 1:ncol(RC2))
        {
          tmpcor=tmpcor+cor(RC2[,k],tmp[,k],method="pearson")
        }
        tmpcor=tmpcor/ncol(RC2)
        tmpres=rbind(tmpres,tmpcor)
      }
      
      tmpres2=apply(tmpres,2,mean) 
      res=rbind(res,cbind(qq,rd,i,tmpres2))
    }
  }}
#}
colnames(res)=c("qq","rd","i","cor")
```